# This file was *autogenerated* from the file digitalsig.sage
from sage.all_cmdline import *   # import sage library
_sage_const_467 = Integer(467); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_213 = Integer(213); _sage_const_127 = Integer(127); _sage_const_100 = Integer(100); _sage_const_10 = Integer(10); _sage_const_20 = Integer(20)
"""
A good place to learn the algorithm:
https://asecuritysite.com/encryption/elgamal

This algorithm is built upon the discrete log problem.


El Gamel encryption-
Bob chooses chooses:
i) A large prime P
ii) Value G = random val between with 2 <= 2 <= pA -2
iii) Y = G ^ x mod P
iv) Choose the value x randomly as the private key

Public key for Bob is (B,P,Y)
Private key for Alice is x.

Alice takes the public keys then picks some random number k.
She then computes two values:
M = message being sent
a = G^k mod P
b = (Y^k)*m mod P

After this,
Plaintext = M = ((b)/(a^x)) mod P
The message is now decrypted!
"""

def get_k(p):

    while(True):
        rand_val = randint(_sage_const_2 ,p-_sage_const_1 )
        if(gcd(rand_val,p -_sage_const_1 ) == _sage_const_1 ):
            return rand_val
message = _sage_const_100 
print message
# Bobs information
P = random_prime(_sage_const_10 **_sage_const_10 ,_sage_const_10 **_sage_const_20 ) # prime
P = _sage_const_467 
print("P: " + str(P))

a = primitive_root(P)
a = _sage_const_2 
print("a: " + str(a))

x = randint(_sage_const_2 ,(P) -_sage_const_2 )
xA= _sage_const_127 
print("xA: " + str(xA))
Y = mod(a**xA,P)
print("Y: " + str(Y))

print("Private Key: ", x)
print("Public Key: ",P,a,Y)

x = get_k(P)
x = _sage_const_213 
r = a ** x %  P

x_inv = inverse_mod(x,P-_sage_const_1 )
inside = (message - xA*r) * x_inv
s = mod(inside, P-_sage_const_1 )
print x_inv,s

print a ** message % P
print "verify: "
c1 = (Y**r * r ** s) % P
print c1


"""
The actual scheme of this...
#Alice's turn to encrypt
alice_rand = randint(0,2000) # if this is huge, it takes a while...
print ("alice_rand: " + str(alice_rand))

r2 = mod(G^ alice_rand, P)
print("r2: " + str(r2))
t = mod(((Y^alice_rand) * message), P)
print("t: " + str(t))


M = (t/(r2^x)) % P

print("M: the final message... " + str(M))
"""
#print get_k(P)
# signature generation:
